/**
 * @module routes/photos
 * @description Photo metadata and image serving endpoints.
 * Images are streamed from per-project SQLite databases.
 */

import { Readable } from 'node:stream';
import {
  getPhotoById,
  getPhotoByOriginalName,
  getTargetsBySourceId,
  getVisibleTargetsBySourceId,
  getProjectByPhotoId,
  getImageBlob,
  isPhotoDeleted,
} from '../db/queries.js';
import { setImageCacheHeaders, setMetadataCacheHeaders, setMutableMetadataCacheHeaders, computeETag } from '../middleware/cache.js';

export default async function photoRoutes(fastify) {
  // GET /api/v1/photos/:uuid — photo metadata (same shape as legacy JSON)
  fastify.get('/api/v1/photos/:uuid', async (request, reply) => {
    const { uuid } = request.params;
    const photo = getPhotoById(uuid);

    if (!photo || isPhotoDeleted(uuid)) {
      reply.code(404);
      return { error: 'Photo not found' };
    }

    setMutableMetadataCacheHeaders(reply);

    const includeHidden = request.query.include_hidden === 'true';
    const targets = includeHidden
      ? getTargetsBySourceId(uuid)
      : getVisibleTargetsBySourceId(uuid);
    const project = getProjectByPhotoId(uuid);

    return {
      camera: {
        id: photo.id,
        img: photo.id,
        display_name: photo.display_name,
        lon: photo.lon,
        lat: photo.lat,
        ele: photo.ele,
        heading: photo.heading,
        height: photo.camera_height,
        mesh_rotation_y: photo.mesh_rotation_y,
        mesh_rotation_x: photo.mesh_rotation_x,
        mesh_rotation_z: photo.mesh_rotation_z,
        distance_scale: photo.distance_scale,
        marker_scale: photo.marker_scale,
        floor_level: photo.floor_level,
        calibration_reviewed: Boolean(photo.calibration_reviewed),
      },
      projectSlug: project?.slug ?? null,
      captureDate: project?.capture_date ?? null,
      targets: targets.map(t => ({
        id: t.target_id,
        img: t.target_id,
        lon: t.lon,
        lat: t.lat,
        ele: t.ele,
        display_name: t.display_name,
        icon: t.is_next ? 'next' : undefined,
        next: Boolean(t.is_next),
        is_original: Boolean(t.is_original),
        distance: t.distance_m,
        bearing: t.bearing_deg,
        override_bearing: t.override_bearing ?? null,
        override_distance: t.override_distance ?? null,
        override_height: t.override_height ?? null,
        ...(includeHidden ? { hidden: Boolean(t.hidden) } : {}),
      })),
    };
  });

  // GET /api/v1/photos/:uuid/image?quality=full|preview — serve image from SQLite BLOB
  fastify.get('/api/v1/photos/:uuid/image', async (request, reply) => {
    const { uuid } = request.params;
    const quality = request.query.quality || 'full';

    const column = quality === 'preview' ? 'preview_webp' : 'full_webp';

    // Find which project DB holds this photo
    const project = getProjectByPhotoId(uuid);
    if (!project || isPhotoDeleted(uuid)) {
      reply.code(404);
      return { error: 'Photo not found' };
    }

    const imageBuffer = getImageBlob(project.db_filename, uuid, column);
    if (!imageBuffer) {
      reply.code(404);
      return { error: 'Image not found' };
    }

    // ETag for conditional requests
    const etag = computeETag(imageBuffer);
    const ifNoneMatch = request.headers['if-none-match'];
    if (ifNoneMatch && ifNoneMatch.replace(/"/g, '') === etag) {
      reply.code(304);
      return;
    }

    setImageCacheHeaders(reply, etag);
    reply.header('Content-Type', 'image/webp');
    reply.header('Content-Length', imageBuffer.length);

    // Stream the buffer without copying
    return reply.send(Readable.from(imageBuffer));
  });

  // GET /api/v1/photos/by-name/:originalName — backward compat lookup
  fastify.get('/api/v1/photos/by-name/:originalName', async (request, reply) => {
    const { originalName } = request.params;
    const photo = getPhotoByOriginalName(originalName);

    if (!photo) {
      reply.code(404);
      return { error: 'Photo not found' };
    }

    setMetadataCacheHeaders(reply);
    return {
      id: photo.id,
      originalName: photo.original_name,
      displayName: photo.display_name,
    };
  });

  // HEAD /api/v1/photos/:uuid is auto-generated by Fastify (exposeHeadRoutes: true)
  // for the GET route above, returning 200 for existing photos and 404 for missing ones.
}
